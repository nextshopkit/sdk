{"version":3,"sources":["../src/utils/resolveShopifyFiles.ts","../src/index.ts","../src/graphql/client.ts","../src/graphql/queries/getProductByHandle.ts","../src/graphql/queries/getProductById.ts","../src/utils/buildMetafieldIdentifiers.ts","../src/utils/normalizeMetafields.ts","../src/utils/parseStringifiedArray.ts","../src/utils/castMetafieldValue.ts","../src/utils/renderRichText.ts","../src/utils/castMetafields.ts","../src/utils/safeParseArray.ts","../src/utils/camelizeKeys.ts","../src/products/getProduct.ts","../src/graphql/queries/getCollectionProducts.ts","../src/utils/formatAvailableFilters.ts","../src/products/getProducts.ts"],"sourcesContent":["const FILES_QUERY = `\n    query getFiles($ids: [ID!]!) {\n    nodes(ids: $ids) {\n        ... on GenericFile {\n        id\n        url\n        mimeType\n        alt\n        originalFileSize\n        previewImage {\n            id\n            url\n        }\n        }\n    }\n    }\n`;\n\nexport async function resolveShopifyFiles(\n  fileIds: string[],\n  fetchShopify: (query: string, variables?: Record<string, any>) => Promise<any>\n): Promise<Record<string, any>> {\n  const resultMap: Record<string, any> = {};\n  if (fileIds.length === 0) return resultMap;\n\n  try {\n    const res = await fetchShopify(FILES_QUERY, { ids: fileIds });\n    const nodes = res.data?.nodes || [];\n\n    for (const file of nodes) {\n      if (file?.id) {\n        resultMap[file.id] = file;\n      }\n    }\n\n    return resultMap;\n  } catch (err) {\n    console.error(\"Error resolving files:\", err);\n    return resultMap;\n  }\n}\n","export * from \"./products/getProduct\";\nexport * from \"./products/getProducts\";\n","const SHOPIFY_GRAPHQL_URL = process.env.SHOPIFY_GRAPHQL_URL!;\nconst SHOPIFY_ACCESS_TOKEN = process.env.SHOPIFY_ACCESS_TOKEN!;\nconst REQUIRED_API_VERSION = \"2025-01\";\n\nexport async function fetchShopify<T = any>(\n  query: string,\n  variables: Record<string, any> = {}\n): Promise<T> {\n  if (!SHOPIFY_GRAPHQL_URL || !SHOPIFY_ACCESS_TOKEN) {\n    throw new Error(\"Missing Shopify API credentials\");\n  }\n\n  // ðŸ›¡ï¸ Optional: Warn if API version isn't correct\n  const versionMatch = SHOPIFY_GRAPHQL_URL.match(\n    /\\/api\\/([\\d-]+)\\/graphql\\.json/\n  );\n  const currentVersion = versionMatch?.[1];\n\n  if (currentVersion && currentVersion !== REQUIRED_API_VERSION) {\n    console.warn(\n      `âš ï¸ Shopify Storefront API version \"${currentVersion}\" detected. This SDK requires \"${REQUIRED_API_VERSION}\" for full compatibility. Some features may not work as expected.`\n    );\n  }\n\n  const res = await fetch(SHOPIFY_GRAPHQL_URL, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      \"X-Shopify-Storefront-Access-Token\": SHOPIFY_ACCESS_TOKEN,\n    },\n    body: JSON.stringify({ query, variables }),\n  });\n\n  const json = await res.json();\n\n  if (json.errors) {\n    throw new Error(json.errors[0]?.message || \"GraphQL error\");\n  }\n\n  return json;\n}\n","export const getProductByHandleQuery = (metafieldIdentifiers: string) => `\n  query getProductByHandle($handle: String!) {\n    productByHandle(handle: $handle) {\n      id\n      title\n      handle\n      descriptionHtml\n      featuredImage {\n        originalSrc\n        altText\n      }\n      images(first: 10) {\n        edges {\n          node {\n            originalSrc\n            altText\n          }\n        }\n      }\n      variants(first: 10) {\n        edges {\n          node {\n            id\n            title\n            priceV2 { amount, currencyCode }\n            compareAtPriceV2 { amount, currencyCode }\n            product { title, handle }\n          }\n        }\n      }\n      metafields(identifiers: [${metafieldIdentifiers}]) {\n        key\n        value\n      }\n    }\n  }\n`;\n","export const getProductByIdQuery = (metafieldIdentifiers: string) => `\n  query getProductById($id: ID!) {\n    node(id: $id) {\n      ... on Product {\n        id\n        title\n        handle\n        descriptionHtml\n        featuredImage {\n          originalSrc\n          altText\n        }\n        images(first: 10) {\n          edges {\n            node {\n              originalSrc\n              altText\n            }\n          }\n        }\n        variants(first: 10) {\n          edges {\n            node {\n              id\n              title\n              priceV2 { amount, currencyCode }\n              compareAtPriceV2 { amount, currencyCode }\n              product { title, handle }\n            }\n          }\n        }\n        metafields(identifiers: [${metafieldIdentifiers}]) {\n          key\n          value\n        }\n      }\n    }\n  }\n`;\n","import { CustomMetafieldDefinition } from \"../types/metafields\";\n\nexport function buildMetafieldIdentifiers(\n  metafields: CustomMetafieldDefinition[]\n): string {\n  return metafields\n    .map(({ field }) => {\n      const [namespace, key] = field.split(\".\");\n      return `{ namespace: \"${namespace}\", key: \"${key}\" }`;\n    })\n    .join(\",\\n\");\n}\n","import { CustomMetafieldDefinition } from \"../types/metafields\";\n\ntype Metafield = { key: string; value: string };\n\nexport function normalizeMetafields(\n  metafields: (Metafield | null)[],\n  definitions: CustomMetafieldDefinition[]\n): Record<string, any> {\n  const result: Record<string, any> = {};\n\n  // Build a map from key â†’ namespace based on definitions\n  const keyToNamespace = new Map<string, string>();\n  for (const def of definitions) {\n    const [namespace, key] = def.field.split(\".\");\n    keyToNamespace.set(key, namespace);\n  }\n\n  for (const field of metafields) {\n    if (!field?.key) continue;\n\n    const key = field.key;\n    const namespace = keyToNamespace.get(key) || \"global\";\n\n    if (!result[namespace]) {\n      result[namespace] = {};\n    }\n\n    result[namespace][key] = field.value;\n  }\n\n  return result;\n}\n","/**\n * Attempts to parse raw JSON (stringified arrays).\n */\nexport function parseStringifiedArray(value: string): string[] | string {\n  try {\n    const parsed = JSON.parse(value);\n    return Array.isArray(parsed) ? parsed : value;\n  } catch {\n    return value;\n  }\n}\n","import { ShopifyCustomFieldType } from \"../types/metafields\";\nimport { parseStringifiedArray } from \"./parseStringifiedArray\";\n\nexport function castMetafieldValue(\n  rawValue: string,\n  type: ShopifyCustomFieldType\n): unknown {\n  switch (type) {\n    case \"integer\":\n    case \"decimal\":\n    case \"money\":\n    case \"rating\":\n    case \"weight\":\n    case \"volume\":\n    case \"dimension\":\n      return Number(rawValue);\n\n    case \"true_false\":\n      return rawValue === \"true\";\n\n    case \"json\":\n      try {\n        return JSON.parse(rawValue);\n      } catch {\n        return rawValue; // fallback to raw string if invalid\n      }\n\n    case \"date\":\n    case \"date_and_time\":\n      return new Date(rawValue); // returns a JS Date object\n\n    case \"color\":\n    case \"url\":\n    case \"id\":\n    case \"single_line_text\":\n    case \"multi_line_text\":\n    case \"rich_text\":\n      return rawValue;\n\n    case \"Product\":\n    case \"Product_variant\":\n    case \"Customer\":\n    case \"Company\":\n    case \"Page\":\n    case \"Collection\":\n    case \"File\":\n    case \"Metaobject\":\n      return parseStringifiedArray(rawValue);\n\n    default:\n      return rawValue;\n  }\n}\n","/**\n * Converts Shopify rich_text schema (JSON) to HTML.\n *\n * @param schema - The rich text schema object or JSON string.\n * @param options - Conversion options.\n * @param options.scoped - A string for a CSS class name or `true` to use the default (\"rte\").\n * @param options.classes - Optional mapping of tag names to CSS class names.\n * @param options.newLineToBreak - If true, converts newlines in plain text to <br>.\n * @returns The resulting HTML string.\n */\nexport function renderRichText(\n  schema: any,\n  options: {\n    scoped?: string | boolean;\n    classes?: Record<string, string>;\n    newLineToBreak?: boolean;\n  } = {}\n): string {\n  let { scoped, classes, newLineToBreak } = options;\n  let html = \"\";\n\n  // If schema is a JSON string, parse it.\n  if (typeof schema === \"string\") {\n    try {\n      schema = JSON.parse(schema);\n    } catch (error) {\n      console.error(\"Error parsing rich text schema:\", error);\n      return schema; // fallback: return the original string\n    }\n  }\n\n  // Allow options itself to be provided as a simple value for scoped\n  if (typeof options === \"string\" || typeof options === \"boolean\") {\n    scoped = options;\n  }\n\n  // If schema is the root object with children\n  if (\n    schema &&\n    schema.type === \"root\" &&\n    Array.isArray(schema.children) &&\n    schema.children.length > 0\n  ) {\n    if (scoped) {\n      const className = scoped === true ? \"rte\" : scoped;\n      html += `<div class=\"${className}\">${renderRichText(\n        schema.children,\n        options\n      )}</div>`;\n    } else {\n      html += renderRichText(schema.children, options);\n    }\n  } else if (Array.isArray(schema)) {\n    // Iterate over each element in the array\n    for (const el of schema) {\n      switch (el.type) {\n        case \"paragraph\":\n          html += buildParagraph(el, options);\n          break;\n        case \"heading\":\n          html += buildHeading(el, options);\n          break;\n        case \"list\":\n          html += buildList(el, options);\n          break;\n        case \"list-item\":\n          html += buildListItem(el, options);\n          break;\n        case \"link\":\n          html += buildLink(el, options);\n          break;\n        case \"text\":\n          html += buildText(el, options);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n  return html;\n}\n\nfunction getClass(\n  tag: string,\n  classes?: Record<string, string>\n): string | null {\n  if (classes && classes[tag]) {\n    return classes[tag];\n  }\n  return null;\n}\n\nfunction outputAttributes(attributes: Record<string, any>): string {\n  if (!attributes) return \"\";\n  return Object.keys(attributes)\n    .filter((key) => attributes[key])\n    .map((key) => ` ${key}=\"${attributes[key]}\"`)\n    .join(\"\");\n}\n\nfunction createElement(\n  tag: string,\n  classes: Record<string, string> | undefined,\n  content: string,\n  attributes: Record<string, any> = {}\n): string {\n  const className = getClass(tag, classes);\n  if (className) {\n    attributes = { ...attributes, class: className };\n  }\n  return `<${tag}${outputAttributes(attributes)}>${content}</${tag}>`;\n}\n\nfunction buildParagraph(el: any, options: any): string {\n  const { classes } = options;\n  return createElement(\"p\", classes, renderRichText(el?.children, options));\n}\n\nfunction buildHeading(el: any, options: any): string {\n  const { classes } = options;\n  const tag = `h${el?.level || 1}`;\n  return createElement(tag, classes, renderRichText(el?.children, options));\n}\n\nfunction buildList(el: any, options: any): string {\n  const { classes } = options;\n  const tag = el?.listType === \"ordered\" ? \"ol\" : \"ul\";\n  return createElement(tag, classes, renderRichText(el?.children, options));\n}\n\nfunction buildListItem(el: any, options: any): string {\n  const { classes } = options;\n  return createElement(\"li\", classes, renderRichText(el?.children, options));\n}\n\nfunction buildLink(el: any, options: any): string {\n  const { classes } = options;\n  const attributes = {\n    href: el?.url,\n    title: el?.title,\n    target: el?.target,\n  };\n  return createElement(\n    \"a\",\n    classes,\n    renderRichText(el?.children, options),\n    attributes\n  );\n}\n\nfunction buildText(el: any, options: any): string {\n  const { classes, newLineToBreak } = options;\n  if (el?.bold && el?.italic) {\n    return createElement(\n      \"strong\",\n      classes,\n      createElement(\"em\", classes, el?.value)\n    );\n  } else if (el?.bold) {\n    return createElement(\"strong\", classes, el?.value);\n  } else if (el?.italic) {\n    return createElement(\"em\", classes, el?.value);\n  } else {\n    return newLineToBreak\n      ? el?.value?.replace(/\\n/g, \"<br>\") || \"\"\n      : el?.value || \"\";\n  }\n}\n","import {\n  CustomMetafieldDefinition,\n  ResolvedMetafieldInfo,\n} from \"../types/metafields\";\nimport { castMetafieldValue } from \"./castMetafieldValue\";\nimport { renderRichText } from \"./renderRichText\";\n\n/**\n * Casts normalized metafields to their correct types.\n * @param normalizedMetafields - Output from normalizeMetafields (nested by namespace).\n * @param definitions - Array of custom metafield definitions.\n * @param renderRichTextAsHtml - If true, rich_text fields are rendered as HTML.\n * @param transformMetafields - Optional post-processing function.\n * @param resolveFiles - Whether to resolve File GIDs into file objects.\n * @param fetchShopify - Required for resolving File types.\n * @returns A nested object with properly cast metafield values.\n */\nexport async function castMetafields(\n  normalizedMetafields: Record<string, Record<string, string>>,\n  definitions: CustomMetafieldDefinition[],\n  renderRichTextAsHtml: boolean,\n  transformMetafields?: (\n    raw: Record<string, Record<string, string>>,\n    casted: Record<string, any>,\n    definitions: ResolvedMetafieldInfo[]\n  ) => Record<string, any> | Promise<Record<string, any>>,\n  resolveFiles: boolean = false,\n  fetchShopify?: (\n    query: string,\n    variables?: Record<string, any>\n  ) => Promise<any>\n): Promise<Record<string, any>> {\n  const result: Record<string, any> = {};\n  const resolvedDefs: ResolvedMetafieldInfo[] = [];\n  const fileGIDs: string[] = [];\n\n  for (const def of definitions) {\n    const [namespace, key] = def.field.split(\".\");\n    const rawValue = normalizedMetafields?.[namespace]?.[key];\n\n    resolvedDefs.push({\n      namespace,\n      key,\n      fullKey: def.field,\n      type: def.type,\n    });\n\n    if (rawValue === undefined) continue;\n    result[namespace] = result[namespace] || {};\n\n    // Rich text HTML\n    if (def.type === \"rich_text\" && renderRichTextAsHtml) {\n      result[namespace][key] = renderRichText(rawValue);\n      continue;\n    }\n\n    // File types\n    if (def.type === \"File\" && resolveFiles) {\n      const casted = castMetafieldValue(rawValue, def.type);\n\n      if (Array.isArray(casted)) {\n        fileGIDs.push(...casted);\n      } else if (typeof casted === \"string\") {\n        fileGIDs.push(casted);\n      }\n\n      result[namespace][key] = casted;\n      continue;\n    }\n\n    // All other types\n    result[namespace][key] = castMetafieldValue(rawValue, def.type);\n  }\n\n  // ðŸ§© Resolve File GIDs to actual file objects\n  if (resolveFiles && fileGIDs.length > 0 && fetchShopify) {\n    const { resolveShopifyFiles } = await import(\"./resolveShopifyFiles\");\n    const fileMap = await resolveShopifyFiles(fileGIDs, fetchShopify);\n\n    for (const def of definitions) {\n      if (def.type !== \"File\") continue;\n      const [namespace, key] = def.field.split(\".\");\n      const raw = result[namespace]?.[key];\n\n      if (Array.isArray(raw)) {\n        result[namespace][key] = raw.map((gid: string) => fileMap[gid] || gid);\n      } else if (typeof raw === \"string\") {\n        result[namespace][key] = fileMap[raw] || raw;\n      }\n    }\n  }\n\n  // ðŸ§  Final transformation\n  if (typeof transformMetafields === \"function\") {\n    return transformMetafields(normalizedMetafields, result, resolvedDefs);\n  }\n\n  return result;\n}\n","// utils/safeParseArray.ts\nexport function safeParseArray<T = any>(value: T[] | null | undefined): T[] {\n  return Array.isArray(value) ? value : [];\n}\n","import { camelCase } from \"lodash\";\n\nexport function camelizeMetafields(obj: any): any {\n  if (Array.isArray(obj)) {\n    return obj.map(camelizeMetafields);\n  }\n\n  if (obj !== null && typeof obj === \"object\") {\n    return Object.fromEntries(\n      Object.entries(obj).map(([key, value]) => [\n        camelCase(key),\n        camelizeMetafields(value),\n      ])\n    );\n  }\n\n  // Don't transform strings or primitives\n  return obj;\n}\n","// GRAPHQL\nimport { fetchShopify } from \"../graphql/client\";\nimport { getProductByHandleQuery } from \"../graphql/queries/getProductByHandle\";\nimport { getProductByIdQuery } from \"../graphql/queries/getProductById\";\n\n// UTILS\nimport { buildMetafieldIdentifiers } from \"../utils/buildMetafieldIdentifiers\";\nimport { normalizeMetafields } from \"../utils/normalizeMetafields\";\nimport { castMetafields } from \"../utils/castMetafields\";\nimport { safeParseArray } from \"../utils/safeParseArray\";\nimport { camelizeMetafields } from \"../utils/camelizeKeys\";\n\n// TYPES\nimport {\n  FetchProductResult,\n  GetProductOptions,\n  Product,\n  Variant,\n  VariantEdge,\n} from \"../types/product\";\nimport { ImageEdge } from \"../types/edges\";\n\nexport async function getProduct(\n  options: GetProductOptions\n): Promise<FetchProductResult> {\n  const { handle, id, customMetafields = [], options: settings } = options;\n  const {\n    locale,\n    renderRichTextAsHtml = false,\n    camelizeKeys = true,\n    resolveFiles = true,\n    transformMetafields,\n  } = settings;\n\n  if (!handle && !id) {\n    return { data: null, error: \"Either handle or id must be provided\" };\n  }\n\n  // Build metafield identifiers based on the provided definitions.\n  const metafieldIdentifiers =\n    customMetafields.length > 0\n      ? buildMetafieldIdentifiers(customMetafields)\n      : \"\";\n\n  // Choose the proper query based on the provided identifier.\n  const query = id\n    ? getProductByIdQuery(metafieldIdentifiers)\n    : getProductByHandleQuery(metafieldIdentifiers);\n\n  // Pass locale if available (for localized fields).\n  const variables = id ? { id } : { handle, locale };\n\n  try {\n    const json = await fetchShopify(query, variables);\n\n    if (json.errors?.length) {\n      return {\n        data: null,\n        error: json.errors[0]?.message || \"GraphQL error\",\n      };\n    }\n\n    // For id query, product is returned as \"node\"; for handle query, as \"productByHandle\".\n    const node = id ? json.data?.node : json.data?.productByHandle;\n\n    if (!node) {\n      return { data: null, error: \"Product not found\" };\n    }\n\n    // Normalize raw metafields (e.g. transform keys \"custom.category\" into nested objects)\n    const rawMetafields = normalizeMetafields(\n      node.metafields || [],\n      customMetafields\n    );\n    // Cast the metafields to proper JS types, optionally transforming them.\n\n    const castedMetafields =\n      customMetafields.length > 0\n        ? await castMetafields(\n            rawMetafields,\n            customMetafields,\n            renderRichTextAsHtml,\n            transformMetafields,\n            resolveFiles,\n            fetchShopify\n          )\n        : rawMetafields;\n\n    const metafields =\n      camelizeKeys !== false\n        ? camelizeMetafields(castedMetafields)\n        : castedMetafields;\n\n    let images = safeParseArray<ImageEdge>(node.images?.edges).map((edge) => ({\n      originalSrc: edge.node.originalSrc,\n      altText: edge.node.altText ?? null,\n    }));\n\n    const variants: Variant[] = safeParseArray(node.variants?.edges).map(\n      (edge: VariantEdge) => {\n        const variant = edge.node;\n        return {\n          id: variant.id,\n          productTitle: variant.product?.title || node.title,\n          variantTitle:\n            variant.title === \"Default Title\" ? node.title : variant.title,\n          price: {\n            amount: parseFloat(variant.priceV2.amount), // number\n            currencyCode: variant.priceV2.currencyCode,\n          },\n          compareAtPrice: variant.compareAtPriceV2\n            ? {\n                amount: parseFloat(variant.compareAtPriceV2.amount),\n                currencyCode: variant.compareAtPriceV2?.currencyCode,\n              }\n            : null,\n        };\n      }\n    );\n\n    const defaultPrice = variants[0]?.price\n      ? {\n          amount: variants[0].price.amount, // number\n          currencyCode: variants[0].price.currencyCode,\n        }\n      : {\n          amount: 0.0,\n          currencyCode: \"EUR\",\n        };\n\n    const defaultCompareAtPrice = variants[0]?.compareAtPrice\n      ? {\n          amount: variants[0].compareAtPrice.amount,\n          currencyCode: variants[0].compareAtPrice.currencyCode,\n        }\n      : null;\n\n    const product: Product = {\n      id: node.id,\n      title: node.title,\n      handle: node.handle,\n      descriptionHtml: node.descriptionHtml || \"\",\n      featuredImage: node.featuredImage || null,\n      images,\n      variants,\n      price: defaultPrice,\n      compareAtPrice: defaultCompareAtPrice,\n      metafields,\n    };\n\n    return { data: product, error: null };\n  } catch (err) {\n    return {\n      data: null,\n      error: err instanceof Error ? err.message : \"Unexpected error\",\n    };\n  }\n}\n","export function getCollectionProductsQuery(\n  limit: number,\n  metafieldIdentifiers: string,\n  hasFilters: boolean\n): string {\n  return `\n    query getCollectionProducts(\n      $handle: String!,\n      $cursor: String,\n      ${hasFilters ? \"$filters: [ProductFilter!],\" : \"\"}\n      $sortKey: ProductCollectionSortKeys,\n      $reverse: Boolean\n    ) {\n      collection(handle: $handle) {\n        id\n        title\n        handle\n        products(\n          first: ${limit},\n          after: $cursor,\n          sortKey: $sortKey,\n          reverse: $reverse\n          ${hasFilters ? \"filters: $filters,\" : \"\"}\n        ) {\n          pageInfo {\n            hasNextPage\n            hasPreviousPage\n            startCursor\n            endCursor\n          }\n          filters {\n            id\n            label\n            values {\n              id\n              label\n              count\n            }\n          }\n          edges {\n            node {\n              id\n              title\n              handle\n              descriptionHtml\n              featuredImage {\n                originalSrc\n                altText\n              }\n              images(first: 10) {\n                edges {\n                  node {\n                    originalSrc\n                    altText\n                  }\n                }\n              }\n              variants(first: 10) {\n                edges {\n                  node {\n                    id\n                    title\n                    priceV2 { amount currencyCode }\n                    compareAtPriceV2 { amount currencyCode }\n                    product { title handle }\n                  }\n                }\n              }\n              metafields(identifiers: [${metafieldIdentifiers}]) {\n                key\n                value\n              }\n            }\n          }\n        }\n      }\n    }\n  `;\n}\n","import { FilterGroup } from \"../types/products\";\nimport { safeParseArray } from \"./safeParseArray\";\n\nexport function formatAvailableFilters(rawFilters: any[]): FilterGroup[] {\n  return rawFilters.map((group) => ({\n    id: group.id,\n    label: group.label,\n    values: safeParseArray(group.values).map((value: any) => ({\n      id: value.id,\n      label: value.label,\n      count: value.count,\n    })),\n  }));\n}\n","// GRAPHQL\nimport { fetchShopify } from \"../graphql/client\";\nimport { getCollectionProductsQuery } from \"../graphql/queries/getCollectionProducts\";\n\n// UTILS\nimport { buildMetafieldIdentifiers } from \"../utils/buildMetafieldIdentifiers\";\nimport { normalizeMetafields } from \"../utils/normalizeMetafields\";\nimport { castMetafields } from \"../utils/castMetafields\";\nimport { safeParseArray } from \"../utils/safeParseArray\";\nimport { camelizeMetafields } from \"../utils/camelizeKeys\";\nimport { formatAvailableFilters } from \"../utils/formatAvailableFilters\";\n\n// TYPES\nimport type { Product, Variant, VariantEdge } from \"../types/product\";\nimport type {\n  FetchProductsResult,\n  ProductsPageInfo,\n  FilterGroup,\n  GetProductsOptions,\n} from \"../types/products\";\n\nexport async function getProducts(\n  config: GetProductsOptions\n): Promise<FetchProductsResult> {\n  const {\n    collectionHandle,\n    limit = 12,\n    cursor,\n    reverse = false,\n    sortKey = \"RELEVANCE\",\n    filters = [],\n    customMetafields = [],\n    options: {\n      resolveFiles = true,\n      renderRichTextAsHtml = false,\n      transformMetafields,\n      camelizeKeys = true,\n    } = {},\n  } = config;\n\n  const metafieldIdentifiers =\n    customMetafields.length > 0\n      ? buildMetafieldIdentifiers(customMetafields)\n      : \"\";\n\n  const query = getCollectionProductsQuery(\n    limit,\n    metafieldIdentifiers,\n    filters.length > 0\n  );\n\n  const variables = {\n    handle: collectionHandle,\n    cursor,\n    reverse,\n    sortKey,\n    filters,\n  };\n\n  try {\n    const json = await fetchShopify(query, variables);\n    const collection = json.data?.collection;\n\n    if (!collection || !collection.products) {\n      return {\n        data: [],\n        pageInfo: {\n          hasNextPage: false,\n          hasPreviousPage: false,\n          endCursor: null,\n          startCursor: null,\n        },\n        error: \"Collection or products not found\",\n      };\n    }\n\n    const edges = safeParseArray(collection.products.edges);\n    const products: Product[] = [];\n\n    for (const edge of edges) {\n      const node = edge.node;\n\n      const rawMetafields = normalizeMetafields(\n        node.metafields || [],\n        customMetafields\n      );\n\n      const castedMetafields =\n        customMetafields.length > 0\n          ? await castMetafields(\n              rawMetafields,\n              customMetafields,\n              renderRichTextAsHtml,\n              transformMetafields,\n              resolveFiles,\n              fetchShopify\n            )\n          : rawMetafields;\n\n      const metafields =\n        camelizeKeys !== false\n          ? camelizeMetafields(castedMetafields)\n          : castedMetafields;\n\n      const variants: Variant[] = safeParseArray(node.variants?.edges).map(\n        (edge: VariantEdge) => {\n          const variant = edge.node;\n          return {\n            id: variant.id,\n            productTitle: variant.product?.title || node.title,\n            variantTitle:\n              variant.title === \"Default Title\" ? node.title : variant.title,\n            price: {\n              amount: parseFloat(variant.priceV2.amount), // number\n              currencyCode: variant.priceV2.currencyCode,\n            },\n            compareAtPrice: variant.compareAtPriceV2\n              ? {\n                  amount: parseFloat(variant.compareAtPriceV2.amount),\n                  currencyCode: variant.compareAtPriceV2?.currencyCode,\n                }\n              : null,\n          };\n        }\n      );\n\n      const product: Product = {\n        id: node.id,\n        title: node.title,\n        handle: node.handle,\n        descriptionHtml: node.descriptionHtml || \"\",\n        featuredImage: node.featuredImage || null,\n        images: safeParseArray(node.images?.edges).map((edge) => edge.node),\n        variants,\n        price: {\n          amount: variants[0]?.price?.amount,\n          currencyCode: variants[0]?.price?.currencyCode,\n        },\n        compareAtPrice: variants[0]?.compareAtPrice\n          ? {\n              amount: variants[0].compareAtPrice.amount,\n              currencyCode: variants[0].compareAtPrice.currencyCode,\n            }\n          : null,\n        metafields,\n      };\n\n      products.push(product);\n    }\n\n    const pageInfo: ProductsPageInfo = collection.products.pageInfo;\n    const rawFilters = collection.products.filters || [];\n    const availableFilters: FilterGroup[] = formatAvailableFilters(rawFilters);\n\n    return { data: products, pageInfo, availableFilters, error: null };\n  } catch (error) {\n    return {\n      data: [],\n      pageInfo: {\n        hasNextPage: false,\n        hasPreviousPage: false,\n        endCursor: null,\n        startCursor: null,\n      },\n      error: error instanceof Error ? error.message : \"Unexpected error\",\n    };\n  }\n}\n"],"mappings":"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","names":["fetchShopify","fetchShopify","resolveShopifyFiles","edge"]}