{"version":3,"sources":["../src/index.ts","../src/graphql/client.ts","../src/graphql/queries/getProductByHandle.ts","../src/graphql/queries/getProductById.ts","../src/utils/buildMetafieldIdentifiers.ts","../src/utils/normalizeMetafields.ts","../src/utils/castMetafieldValue.ts","../src/utils/renderRichText.ts","../src/utils/castMetafields.ts","../src/products/getProduct.ts"],"sourcesContent":["export * from \"./products/getProduct\";\n","const SHOPIFY_GRAPHQL_URL = process.env.SHOPIFY_GRAPHQL_URL!;\nconst SHOPIFY_ACCESS_TOKEN = process.env.SHOPIFY_ACCESS_TOKEN!;\n\nexport async function fetchShopify<T = any>(\n  query: string,\n  variables: Record<string, any> = {}\n): Promise<T> {\n  if (!SHOPIFY_GRAPHQL_URL || !SHOPIFY_ACCESS_TOKEN) {\n    throw new Error(\"Missing Shopify API credentials\");\n  }\n  const res = await fetch(SHOPIFY_GRAPHQL_URL, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      \"X-Shopify-Storefront-Access-Token\": SHOPIFY_ACCESS_TOKEN,\n    },\n    body: JSON.stringify({ query, variables }),\n  });\n  const json = await res.json();\n  if (json.errors) {\n    throw new Error(json.errors[0]?.message || \"GraphQL error\");\n  }\n  return json;\n}\n","export const getProductByHandleQuery = (metafieldIdentifiers: string) => `\n  query getProductByHandle($handle: String!) {\n    productByHandle(handle: $handle) {\n      id\n      title\n      handle\n      descriptionHtml\n      featuredImage {\n        originalSrc\n        altText\n      }\n      images(first: 10) {\n        edges {\n          node {\n            originalSrc\n            altText\n          }\n        }\n      }\n      variants(first: 10) {\n        edges {\n          node {\n            id\n            title\n            priceV2 { amount, currencyCode }\n            compareAtPriceV2 { amount, currencyCode }\n            product { title, handle }\n          }\n        }\n      }\n      metafields(identifiers: [${metafieldIdentifiers}]) {\n        key\n        value\n      }\n    }\n  }\n`;\n","export const getProductByIdQuery = (metafieldIdentifiers: string) => `\n  query getProductById($id: ID!) {\n    node(id: $id) {\n      ... on Product {\n        id\n        title\n        handle\n        descriptionHtml\n        featuredImage {\n          originalSrc\n          altText\n        }\n        images(first: 10) {\n          edges {\n            node {\n              originalSrc\n              altText\n            }\n          }\n        }\n        variants(first: 10) {\n          edges {\n            node {\n              id\n              title\n              priceV2 { amount, currencyCode }\n              compareAtPriceV2 { amount, currencyCode }\n              product { title, handle }\n            }\n          }\n        }\n        metafields(identifiers: [${metafieldIdentifiers}]) {\n          key\n          value\n        }\n      }\n    }\n  }\n`;\n","import { CustomMetafieldDefinition } from \"../types/metafields\";\n\nexport function buildMetafieldIdentifiers(\n  metafields: CustomMetafieldDefinition[]\n): string {\n  return metafields\n    .map(({ field }) => {\n      const [namespace, key] = field.split(\".\");\n      return `{ namespace: \"${namespace}\", key: \"${key}\" }`;\n    })\n    .join(\",\\n\");\n}\n","type Metafield = { key: string; value: string };\n\nexport function normalizeMetafields(\n  metafields: (Metafield | null)[]\n): Record<string, any> {\n  const result: Record<string, any> = {};\n\n  for (const field of metafields) {\n    if (!field?.key) continue;\n    const [namespace, key] = field.key.includes(\".\")\n      ? field.key.split(\".\")\n      : [\"global\", field.key];\n\n    if (!result[namespace]) {\n      result[namespace] = {};\n    }\n\n    result[namespace][key] = field.value;\n  }\n\n  return result;\n}\n","import { ShopifyCustomFieldType } from \"../types/metafields\";\n\nexport function castMetafieldValue(\n  rawValue: string,\n  type: ShopifyCustomFieldType\n): unknown {\n  switch (type) {\n    case \"integer\":\n    case \"decimal\":\n    case \"money\":\n    case \"rating\":\n    case \"weight\":\n    case \"volume\":\n    case \"dimension\":\n      return Number(rawValue);\n\n    case \"true_false\":\n      return rawValue === \"true\";\n\n    case \"json\":\n      try {\n        return JSON.parse(rawValue);\n      } catch {\n        return rawValue; // fallback to raw string if invalid\n      }\n\n    case \"date\":\n    case \"date_and_time\":\n      return new Date(rawValue); // returns a JS Date object\n\n    case \"color\":\n    case \"url\":\n    case \"id\":\n    case \"single_line_text\":\n    case \"multi_line_text\":\n    case \"rich_text\":\n      return rawValue;\n\n    case \"Product\":\n    case \"Product_variant\":\n    case \"Customer\":\n    case \"Company\":\n    case \"Page\":\n    case \"Collection\":\n    case \"File\":\n    case \"Metaobject\":\n      return rawValue; // usually a Shopify GID like gid://shopify/Product/123\n\n    default:\n      return rawValue;\n  }\n}\n","/**\n * Converts Shopify rich_text schema (JSON) to HTML.\n *\n * @param schema - The rich text schema object or JSON string.\n * @param options - Conversion options.\n * @param options.scoped - A string for a CSS class name or `true` to use the default (\"rte\").\n * @param options.classes - Optional mapping of tag names to CSS class names.\n * @param options.newLineToBreak - If true, converts newlines in plain text to <br>.\n * @returns The resulting HTML string.\n */\nexport function renderRichText(\n  schema: any,\n  options: {\n    scoped?: string | boolean;\n    classes?: Record<string, string>;\n    newLineToBreak?: boolean;\n  } = {}\n): string {\n  let { scoped, classes, newLineToBreak } = options;\n  let html = \"\";\n\n  // If schema is a JSON string, parse it.\n  if (typeof schema === \"string\") {\n    try {\n      schema = JSON.parse(schema);\n    } catch (error) {\n      console.error(\"Error parsing rich text schema:\", error);\n      return schema; // fallback: return the original string\n    }\n  }\n\n  // Allow options itself to be provided as a simple value for scoped\n  if (typeof options === \"string\" || typeof options === \"boolean\") {\n    scoped = options;\n  }\n\n  // If schema is the root object with children\n  if (\n    schema &&\n    schema.type === \"root\" &&\n    Array.isArray(schema.children) &&\n    schema.children.length > 0\n  ) {\n    if (scoped) {\n      const className = scoped === true ? \"rte\" : scoped;\n      html += `<div class=\"${className}\">${renderRichText(\n        schema.children,\n        options\n      )}</div>`;\n    } else {\n      html += renderRichText(schema.children, options);\n    }\n  } else if (Array.isArray(schema)) {\n    // Iterate over each element in the array\n    for (const el of schema) {\n      switch (el.type) {\n        case \"paragraph\":\n          html += buildParagraph(el, options);\n          break;\n        case \"heading\":\n          html += buildHeading(el, options);\n          break;\n        case \"list\":\n          html += buildList(el, options);\n          break;\n        case \"list-item\":\n          html += buildListItem(el, options);\n          break;\n        case \"link\":\n          html += buildLink(el, options);\n          break;\n        case \"text\":\n          html += buildText(el, options);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n  return html;\n}\n\nfunction getClass(\n  tag: string,\n  classes?: Record<string, string>\n): string | null {\n  if (classes && classes[tag]) {\n    return classes[tag];\n  }\n  return null;\n}\n\nfunction outputAttributes(attributes: Record<string, any>): string {\n  if (!attributes) return \"\";\n  return Object.keys(attributes)\n    .filter((key) => attributes[key])\n    .map((key) => ` ${key}=\"${attributes[key]}\"`)\n    .join(\"\");\n}\n\nfunction createElement(\n  tag: string,\n  classes: Record<string, string> | undefined,\n  content: string,\n  attributes: Record<string, any> = {}\n): string {\n  const className = getClass(tag, classes);\n  if (className) {\n    attributes = { ...attributes, class: className };\n  }\n  return `<${tag}${outputAttributes(attributes)}>${content}</${tag}>`;\n}\n\nfunction buildParagraph(el: any, options: any): string {\n  const { classes } = options;\n  return createElement(\"p\", classes, renderRichText(el?.children, options));\n}\n\nfunction buildHeading(el: any, options: any): string {\n  const { classes } = options;\n  const tag = `h${el?.level || 1}`;\n  return createElement(tag, classes, renderRichText(el?.children, options));\n}\n\nfunction buildList(el: any, options: any): string {\n  const { classes } = options;\n  const tag = el?.listType === \"ordered\" ? \"ol\" : \"ul\";\n  return createElement(tag, classes, renderRichText(el?.children, options));\n}\n\nfunction buildListItem(el: any, options: any): string {\n  const { classes } = options;\n  return createElement(\"li\", classes, renderRichText(el?.children, options));\n}\n\nfunction buildLink(el: any, options: any): string {\n  const { classes } = options;\n  const attributes = {\n    href: el?.url,\n    title: el?.title,\n    target: el?.target,\n  };\n  return createElement(\n    \"a\",\n    classes,\n    renderRichText(el?.children, options),\n    attributes\n  );\n}\n\nfunction buildText(el: any, options: any): string {\n  const { classes, newLineToBreak } = options;\n  if (el?.bold && el?.italic) {\n    return createElement(\n      \"strong\",\n      classes,\n      createElement(\"em\", classes, el?.value)\n    );\n  } else if (el?.bold) {\n    return createElement(\"strong\", classes, el?.value);\n  } else if (el?.italic) {\n    return createElement(\"em\", classes, el?.value);\n  } else {\n    return newLineToBreak\n      ? el?.value?.replace(/\\n/g, \"<br>\") || \"\"\n      : el?.value || \"\";\n  }\n}\n","import {\n  CustomMetafieldDefinition,\n  ResolvedMetafieldInfo,\n} from \"../types/metafields\";\nimport { castMetafieldValue } from \"./castMetafieldValue\";\nimport { renderRichText } from \"./renderRichText\";\n\n/**\n * Casts normalized metafields to their correct types.\n * @param normalizedMetafields - The output from normalizeMetafields.\n * @param definitions - Array of custom metafield definitions.\n * @param renderRichTextAsHtml - If true, rich_text fields are rendered as HTML.\n * @param transformMetafields - Optional transform function that receives:\n *        raw normalized metafields, the cast result so far, and the array of resolved definitions.\n * @returns A nested object with properly cast metafield values.\n */\nexport function castMetafields(\n  normalizedMetafields: Record<string, Record<string, string>>,\n  definitions: CustomMetafieldDefinition[],\n  renderRichTextAsHtml: boolean,\n  transformMetafields?: (\n    raw: Record<string, Record<string, string>>,\n    casted: Record<string, any>,\n    definitions: ResolvedMetafieldInfo[]\n  ) => Record<string, any>\n): Record<string, any> {\n  const result: Record<string, any> = {};\n  const resolvedDefs: ResolvedMetafieldInfo[] = [];\n\n  for (const def of definitions) {\n    const [namespace, key] = def.field.split(\".\");\n    const rawValue = normalizedMetafields?.[namespace]?.[key];\n\n    // Record resolved definition info\n    resolvedDefs.push({\n      namespace,\n      key,\n      fullKey: def.field,\n      type: def.type,\n    });\n\n    if (rawValue !== undefined) {\n      result[namespace] = result[namespace] || {};\n      if (def.type === \"rich_text\" && renderRichTextAsHtml) {\n        result[namespace][key] = renderRichText(rawValue);\n      } else {\n        result[namespace][key] = castMetafieldValue(rawValue, def.type);\n      }\n    }\n  }\n\n  if (transformMetafields) {\n    return transformMetafields(normalizedMetafields, result, resolvedDefs);\n  }\n  return result;\n}\n","import { fetchShopify } from \"../graphql/client\";\nimport { getProductByHandleQuery } from \"../graphql/queries/getProductByHandle\";\nimport { getProductByIdQuery } from \"../graphql/queries/getProductById\";\nimport { buildMetafieldIdentifiers } from \"../utils/buildMetafieldIdentifiers\";\nimport { normalizeMetafields } from \"../utils/normalizeMetafields\";\nimport { castMetafields } from \"../utils/castMetafields\";\nimport { safeParseArray } from \"../utils/safeParseArray\";\nimport {\n  CustomMetafieldDefinition,\n  ResolvedMetafieldInfo,\n} from \"../types/metafields\";\nimport { FetchProductResult, Product } from \"../types/product\";\nimport { ImageEdge, VariantEdge } from \"../types/edges\";\n\nexport interface GetProductOptions {\n  id?: string;\n  handle?: string;\n  customMetafields?: CustomMetafieldDefinition[];\n  options: {\n    renderRichTextAsHtml?: boolean;\n    includeRawMetafields?: boolean;\n    imageLimit?: number;\n    variantLimit?: number;\n    transformMetafields?: (\n      raw: Record<string, Record<string, string>>,\n      casted: Record<string, any>,\n      definitions: ResolvedMetafieldInfo[]\n    ) => Record<string, any>;\n    locale: string;\n    returnFullResponse: boolean;\n    resolveReferences: true;\n  };\n}\n\nexport async function getProduct(\n  options: GetProductOptions\n): Promise<FetchProductResult> {\n  const { handle, id, customMetafields = [], options: settings } = options;\n  const {\n    renderRichTextAsHtml = false,\n    includeRawMetafields = false,\n    imageLimit,\n    variantLimit,\n    transformMetafields,\n    locale,\n    returnFullResponse,\n    resolveReferences,\n  } = settings;\n\n  if (!handle && !id) {\n    return { data: null, error: \"Either handle or id must be provided\" };\n  }\n\n  // Build metafield identifiers if definitions are provided.\n  const metafieldIdentifiers =\n    customMetafields.length > 0\n      ? buildMetafieldIdentifiers(customMetafields)\n      : \"\";\n\n  // Choose the query based on provided identifier (id vs. handle).\n  const query = id\n    ? getProductByIdQuery(metafieldIdentifiers)\n    : getProductByHandleQuery(metafieldIdentifiers);\n\n  // Pass locale if needed (for localized fields)\n  const variables = id ? { id } : { handle, locale };\n\n  try {\n    const json = await fetchShopify(query, variables);\n\n    if (json.errors?.length) {\n      return {\n        data: null,\n        error: json.errors[0]?.message || \"GraphQL error\",\n      };\n    }\n\n    // For id query, Shopify returns the product under \"node\".\n    // For handle query, it returns it under \"productByHandle\".\n    const node = id ? json.data?.node : json.data?.productByHandle;\n\n    if (!node) {\n      return { data: null, error: \"Product not found\" };\n    }\n\n    // Normalize raw metafields from Shopify.\n    const rawMetafields = normalizeMetafields(node.metafields || []);\n    // Cast metafields using definitions and optionally transform them.\n    const metafields =\n      customMetafields.length > 0\n        ? castMetafields(\n            rawMetafields,\n            customMetafields,\n            renderRichTextAsHtml,\n            transformMetafields\n          )\n        : rawMetafields;\n\n    // Process images; apply imageLimit if provided.\n    let images = (node.images.edges ?? []).map((edge: ImageEdge) => ({\n      originalSrc: edge.node.originalSrc,\n      altText: edge.node.altText ?? null,\n    }));\n    if (imageLimit && images.length > imageLimit) {\n      images = images.slice(0, imageLimit);\n    }\n\n    // Process variants; apply variantLimit if provided.\n    let variants = (node.variants.edges ?? []).map((edge: VariantEdge) => {\n      const variant = edge.node;\n      return {\n        id: variant.id,\n        variantTitle: variant.title,\n        productTitle: variant.product?.title || node.title,\n        price: variant.priceV2,\n        compareAtPrice: variant.compareAtPriceV2 ?? null,\n      };\n    });\n    if (variantLimit && variants.length > variantLimit) {\n      variants = variants.slice(0, variantLimit);\n    }\n\n    const defaultPrice = variants[0]?.price || {\n      amount: \"0\",\n      currencyCode: \"EUR\",\n    };\n    const defaultCompareAtPrice = variants[0]?.compareAtPrice || null;\n\n    const product: Product = {\n      id: node.id,\n      title: node.title,\n      handle: node.handle,\n      descriptionHtml: node.descriptionHtml || \"\",\n      featuredImage: node.featuredImage || null,\n      images,\n      variants,\n      price: defaultPrice,\n      compareAtPrice: defaultCompareAtPrice,\n      metafields,\n    };\n\n    // Optionally include the full raw Shopify response for debugging or other needs.\n    const fullResponse = includeRawMetafields ? json : undefined;\n\n    // If returnFullResponse is true, attach the raw response to the result.\n    return { data: product, error: null, fullResponse };\n  } catch (err) {\n    return {\n      data: null,\n      error: err instanceof Error ? err.message : \"Unexpected error\",\n    };\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,IAAM,sBAAsB,QAAQ,IAAI;AACxC,IAAM,uBAAuB,QAAQ,IAAI;AAEzC,eAAsB,aACpB,OACA,YAAiC,CAAC,GACtB;AACZ,MAAI,CAAC,uBAAuB,CAAC,sBAAsB;AACjD,UAAM,IAAI,MAAM,iCAAiC;AAAA,EACnD;AACA,QAAM,MAAM,MAAM,MAAM,qBAAqB;AAAA,IAC3C,QAAQ;AAAA,IACR,SAAS;AAAA,MACP,gBAAgB;AAAA,MAChB,qCAAqC;AAAA,IACvC;AAAA,IACA,MAAM,KAAK,UAAU,EAAE,OAAO,UAAU,CAAC;AAAA,EAC3C,CAAC;AACD,QAAM,OAAO,MAAM,IAAI,KAAK;AAC5B,MAAI,KAAK,QAAQ;AACf,UAAM,IAAI,MAAM,KAAK,OAAO,CAAC,GAAG,WAAW,eAAe;AAAA,EAC5D;AACA,SAAO;AACT;;;ACvBO,IAAM,0BAA0B,CAAC,yBAAiC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iCA8BxC,oBAAoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AC9B9C,IAAM,sBAAsB,CAAC,yBAAiC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mCA+BlC,oBAAoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AC7BhD,SAAS,0BACd,YACQ;AACR,SAAO,WACJ,IAAI,CAAC,EAAE,MAAM,MAAM;AAClB,UAAM,CAAC,WAAW,GAAG,IAAI,MAAM,MAAM,GAAG;AACxC,WAAO,iBAAiB,SAAS,YAAY,GAAG;AAAA,EAClD,CAAC,EACA,KAAK,KAAK;AACf;;;ACTO,SAAS,oBACd,YACqB;AACrB,QAAM,SAA8B,CAAC;AAErC,aAAW,SAAS,YAAY;AAC9B,QAAI,CAAC,OAAO;AAAK;AACjB,UAAM,CAAC,WAAW,GAAG,IAAI,MAAM,IAAI,SAAS,GAAG,IAC3C,MAAM,IAAI,MAAM,GAAG,IACnB,CAAC,UAAU,MAAM,GAAG;AAExB,QAAI,CAAC,OAAO,SAAS,GAAG;AACtB,aAAO,SAAS,IAAI,CAAC;AAAA,IACvB;AAEA,WAAO,SAAS,EAAE,GAAG,IAAI,MAAM;AAAA,EACjC;AAEA,SAAO;AACT;;;ACnBO,SAAS,mBACd,UACA,MACS;AACT,UAAQ,MAAM;AAAA,IACZ,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AACH,aAAO,OAAO,QAAQ;AAAA,IAExB,KAAK;AACH,aAAO,aAAa;AAAA,IAEtB,KAAK;AACH,UAAI;AACF,eAAO,KAAK,MAAM,QAAQ;AAAA,MAC5B,QAAQ;AACN,eAAO;AAAA,MACT;AAAA,IAEF,KAAK;AAAA,IACL,KAAK;AACH,aAAO,IAAI,KAAK,QAAQ;AAAA,IAE1B,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AACH,aAAO;AAAA,IAET,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AACH,aAAO;AAAA,IAET;AACE,aAAO;AAAA,EACX;AACF;;;ACzCO,SAAS,eACd,QACA,UAII,CAAC,GACG;AACR,MAAI,EAAE,QAAQ,SAAS,eAAe,IAAI;AAC1C,MAAI,OAAO;AAGX,MAAI,OAAO,WAAW,UAAU;AAC9B,QAAI;AACF,eAAS,KAAK,MAAM,MAAM;AAAA,IAC5B,SAAS,OAAO;AACd,cAAQ,MAAM,mCAAmC,KAAK;AACtD,aAAO;AAAA,IACT;AAAA,EACF;AAGA,MAAI,OAAO,YAAY,YAAY,OAAO,YAAY,WAAW;AAC/D,aAAS;AAAA,EACX;AAGA,MACE,UACA,OAAO,SAAS,UAChB,MAAM,QAAQ,OAAO,QAAQ,KAC7B,OAAO,SAAS,SAAS,GACzB;AACA,QAAI,QAAQ;AACV,YAAM,YAAY,WAAW,OAAO,QAAQ;AAC5C,cAAQ,eAAe,SAAS,KAAK;AAAA,QACnC,OAAO;AAAA,QACP;AAAA,MACF,CAAC;AAAA,IACH,OAAO;AACL,cAAQ,eAAe,OAAO,UAAU,OAAO;AAAA,IACjD;AAAA,EACF,WAAW,MAAM,QAAQ,MAAM,GAAG;AAEhC,eAAW,MAAM,QAAQ;AACvB,cAAQ,GAAG,MAAM;AAAA,QACf,KAAK;AACH,kBAAQ,eAAe,IAAI,OAAO;AAClC;AAAA,QACF,KAAK;AACH,kBAAQ,aAAa,IAAI,OAAO;AAChC;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU,IAAI,OAAO;AAC7B;AAAA,QACF,KAAK;AACH,kBAAQ,cAAc,IAAI,OAAO;AACjC;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU,IAAI,OAAO;AAC7B;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU,IAAI,OAAO;AAC7B;AAAA,QACF;AACE;AAAA,MACJ;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAEA,SAAS,SACP,KACA,SACe;AACf,MAAI,WAAW,QAAQ,GAAG,GAAG;AAC3B,WAAO,QAAQ,GAAG;AAAA,EACpB;AACA,SAAO;AACT;AAEA,SAAS,iBAAiB,YAAyC;AACjE,MAAI,CAAC;AAAY,WAAO;AACxB,SAAO,OAAO,KAAK,UAAU,EAC1B,OAAO,CAAC,QAAQ,WAAW,GAAG,CAAC,EAC/B,IAAI,CAAC,QAAQ,IAAI,GAAG,KAAK,WAAW,GAAG,CAAC,GAAG,EAC3C,KAAK,EAAE;AACZ;AAEA,SAAS,cACP,KACA,SACA,SACA,aAAkC,CAAC,GAC3B;AACR,QAAM,YAAY,SAAS,KAAK,OAAO;AACvC,MAAI,WAAW;AACb,iBAAa,EAAE,GAAG,YAAY,OAAO,UAAU;AAAA,EACjD;AACA,SAAO,IAAI,GAAG,GAAG,iBAAiB,UAAU,CAAC,IAAI,OAAO,KAAK,GAAG;AAClE;AAEA,SAAS,eAAe,IAAS,SAAsB;AACrD,QAAM,EAAE,QAAQ,IAAI;AACpB,SAAO,cAAc,KAAK,SAAS,eAAe,IAAI,UAAU,OAAO,CAAC;AAC1E;AAEA,SAAS,aAAa,IAAS,SAAsB;AACnD,QAAM,EAAE,QAAQ,IAAI;AACpB,QAAM,MAAM,IAAI,IAAI,SAAS,CAAC;AAC9B,SAAO,cAAc,KAAK,SAAS,eAAe,IAAI,UAAU,OAAO,CAAC;AAC1E;AAEA,SAAS,UAAU,IAAS,SAAsB;AAChD,QAAM,EAAE,QAAQ,IAAI;AACpB,QAAM,MAAM,IAAI,aAAa,YAAY,OAAO;AAChD,SAAO,cAAc,KAAK,SAAS,eAAe,IAAI,UAAU,OAAO,CAAC;AAC1E;AAEA,SAAS,cAAc,IAAS,SAAsB;AACpD,QAAM,EAAE,QAAQ,IAAI;AACpB,SAAO,cAAc,MAAM,SAAS,eAAe,IAAI,UAAU,OAAO,CAAC;AAC3E;AAEA,SAAS,UAAU,IAAS,SAAsB;AAChD,QAAM,EAAE,QAAQ,IAAI;AACpB,QAAM,aAAa;AAAA,IACjB,MAAM,IAAI;AAAA,IACV,OAAO,IAAI;AAAA,IACX,QAAQ,IAAI;AAAA,EACd;AACA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,eAAe,IAAI,UAAU,OAAO;AAAA,IACpC;AAAA,EACF;AACF;AAEA,SAAS,UAAU,IAAS,SAAsB;AAChD,QAAM,EAAE,SAAS,eAAe,IAAI;AACpC,MAAI,IAAI,QAAQ,IAAI,QAAQ;AAC1B,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA,cAAc,MAAM,SAAS,IAAI,KAAK;AAAA,IACxC;AAAA,EACF,WAAW,IAAI,MAAM;AACnB,WAAO,cAAc,UAAU,SAAS,IAAI,KAAK;AAAA,EACnD,WAAW,IAAI,QAAQ;AACrB,WAAO,cAAc,MAAM,SAAS,IAAI,KAAK;AAAA,EAC/C,OAAO;AACL,WAAO,iBACH,IAAI,OAAO,QAAQ,OAAO,MAAM,KAAK,KACrC,IAAI,SAAS;AAAA,EACnB;AACF;;;ACvJO,SAAS,eACd,sBACA,aACA,sBACA,qBAKqB;AACrB,QAAM,SAA8B,CAAC;AACrC,QAAM,eAAwC,CAAC;AAE/C,aAAW,OAAO,aAAa;AAC7B,UAAM,CAAC,WAAW,GAAG,IAAI,IAAI,MAAM,MAAM,GAAG;AAC5C,UAAM,WAAW,uBAAuB,SAAS,IAAI,GAAG;AAGxD,iBAAa,KAAK;AAAA,MAChB;AAAA,MACA;AAAA,MACA,SAAS,IAAI;AAAA,MACb,MAAM,IAAI;AAAA,IACZ,CAAC;AAED,QAAI,aAAa,QAAW;AAC1B,aAAO,SAAS,IAAI,OAAO,SAAS,KAAK,CAAC;AAC1C,UAAI,IAAI,SAAS,eAAe,sBAAsB;AACpD,eAAO,SAAS,EAAE,GAAG,IAAI,eAAe,QAAQ;AAAA,MAClD,OAAO;AACL,eAAO,SAAS,EAAE,GAAG,IAAI,mBAAmB,UAAU,IAAI,IAAI;AAAA,MAChE;AAAA,IACF;AAAA,EACF;AAEA,MAAI,qBAAqB;AACvB,WAAO,oBAAoB,sBAAsB,QAAQ,YAAY;AAAA,EACvE;AACA,SAAO;AACT;;;ACrBA,eAAsB,WACpB,SAC6B;AAC7B,QAAM,EAAE,QAAQ,IAAI,mBAAmB,CAAC,GAAG,SAAS,SAAS,IAAI;AACjE,QAAM;AAAA,IACJ,uBAAuB;AAAA,IACvB,uBAAuB;AAAA,IACvB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI;AAEJ,MAAI,CAAC,UAAU,CAAC,IAAI;AAClB,WAAO,EAAE,MAAM,MAAM,OAAO,uCAAuC;AAAA,EACrE;AAGA,QAAM,uBACJ,iBAAiB,SAAS,IACtB,0BAA0B,gBAAgB,IAC1C;AAGN,QAAM,QAAQ,KACV,oBAAoB,oBAAoB,IACxC,wBAAwB,oBAAoB;AAGhD,QAAM,YAAY,KAAK,EAAE,GAAG,IAAI,EAAE,QAAQ,OAAO;AAEjD,MAAI;AACF,UAAM,OAAO,MAAM,aAAa,OAAO,SAAS;AAEhD,QAAI,KAAK,QAAQ,QAAQ;AACvB,aAAO;AAAA,QACL,MAAM;AAAA,QACN,OAAO,KAAK,OAAO,CAAC,GAAG,WAAW;AAAA,MACpC;AAAA,IACF;AAIA,UAAM,OAAO,KAAK,KAAK,MAAM,OAAO,KAAK,MAAM;AAE/C,QAAI,CAAC,MAAM;AACT,aAAO,EAAE,MAAM,MAAM,OAAO,oBAAoB;AAAA,IAClD;AAGA,UAAM,gBAAgB,oBAAoB,KAAK,cAAc,CAAC,CAAC;AAE/D,UAAM,aACJ,iBAAiB,SAAS,IACtB;AAAA,MACE;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,IACA;AAGN,QAAI,UAAU,KAAK,OAAO,SAAS,CAAC,GAAG,IAAI,CAAC,UAAqB;AAAA,MAC/D,aAAa,KAAK,KAAK;AAAA,MACvB,SAAS,KAAK,KAAK,WAAW;AAAA,IAChC,EAAE;AACF,QAAI,cAAc,OAAO,SAAS,YAAY;AAC5C,eAAS,OAAO,MAAM,GAAG,UAAU;AAAA,IACrC;AAGA,QAAI,YAAY,KAAK,SAAS,SAAS,CAAC,GAAG,IAAI,CAAC,SAAsB;AACpE,YAAM,UAAU,KAAK;AACrB,aAAO;AAAA,QACL,IAAI,QAAQ;AAAA,QACZ,cAAc,QAAQ;AAAA,QACtB,cAAc,QAAQ,SAAS,SAAS,KAAK;AAAA,QAC7C,OAAO,QAAQ;AAAA,QACf,gBAAgB,QAAQ,oBAAoB;AAAA,MAC9C;AAAA,IACF,CAAC;AACD,QAAI,gBAAgB,SAAS,SAAS,cAAc;AAClD,iBAAW,SAAS,MAAM,GAAG,YAAY;AAAA,IAC3C;AAEA,UAAM,eAAe,SAAS,CAAC,GAAG,SAAS;AAAA,MACzC,QAAQ;AAAA,MACR,cAAc;AAAA,IAChB;AACA,UAAM,wBAAwB,SAAS,CAAC,GAAG,kBAAkB;AAE7D,UAAM,UAAmB;AAAA,MACvB,IAAI,KAAK;AAAA,MACT,OAAO,KAAK;AAAA,MACZ,QAAQ,KAAK;AAAA,MACb,iBAAiB,KAAK,mBAAmB;AAAA,MACzC,eAAe,KAAK,iBAAiB;AAAA,MACrC;AAAA,MACA;AAAA,MACA,OAAO;AAAA,MACP,gBAAgB;AAAA,MAChB;AAAA,IACF;AAGA,UAAM,eAAe,uBAAuB,OAAO;AAGnD,WAAO,EAAE,MAAM,SAAS,OAAO,MAAM,aAAa;AAAA,EACpD,SAAS,KAAK;AACZ,WAAO;AAAA,MACL,MAAM;AAAA,MACN,OAAO,eAAe,QAAQ,IAAI,UAAU;AAAA,IAC9C;AAAA,EACF;AACF;","names":[]}